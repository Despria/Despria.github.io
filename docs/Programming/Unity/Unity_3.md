---
sidebar_position: 3
---

# Unity를 위한 기본 문법 3

이번에는 C#의 가장 중요한 파트라고도 할 수 있는 **클래스**에 대한 내용을 정리해보도록 하겠다. <br />
클래스 개념은 보통 객체 지향 프로그래밍 언어인 C#이나 JAVA등에서 다루는 것으로, <br />
객체 지향 프로그래밍의 핵심 요소인 **상속**, **다형성**, **캡슐화** (+ **추상화**)를 구현하는 것이라 할 수 있다. <br />

---

# 객체 지향 프로그래밍

## 객체 지향 프로그래밍이란?

요즘 시대에 프로그래밍을 배우려는 나와 같은 사람들이 가장 많이 듣거나 본 말 중 하나가 바로 **'객체 지향'** 프로그래밍일 것이다.<br />
그 이유는 프로그래밍에 입문하면서 배우는, 또 현재 쓰이는 많은 언어들이 바로 이 '객체 지향' 언어이기 때문이다.<br />
그런데 이 객체라는 것이 무엇인지 잘 모르겠다. 일반적인 상황에서 '객체'라는 말을 쓰지는 않지 않는가?<br />
그렇기 때문에 기본 문법 2편까지는 그저 단순히 기본 문법에 대해서 정리해보았다면, <br />이번에는 이 객체 지향 프로그래밍에 대해서 짧게 살펴보고 가보도록 하겠다.

객체 지향 프로그래밍, 즉 객체를 지향하는 프로그래밍이라고 하는데, 이게 무슨 뜻일까?<br />
객체라는 말은 즉 사물, 또는 부품이라고 보면 좋을 것 같다.<br />
예를 들어서 볼펜을 한번 살펴보자. 볼펜은 하나의 사물이므로, 볼펜 자체가 곧 객체이다.<br />
하지만 볼펜 뚜껑을 열어보면 그 안에는 볼펜심, 스프링 등 여러 부품들이 있다. 그것들 또한 객체이다.<br />

즉, 객체라는 것은 그 자체로 작동 가능한 하나의 완성품일 수도 있지만, <br />어떤 하나의 완성품을 만들기 위한 개별적으로는 작동 불가능한 부품일 수도 있다.<br />
그렇기에 객체 지향 프로그래밍이라는 것은 어떠한 프로그램, 즉 완성품의 모습을 구상하면서, <br />그 기능을 여러 분리된 객체로 만든 후에, 
프로그래밍을 통해 그러한 객체들을 완성시키고, <br />이 객체들을 조합하여 하나의 완성품을 만들어내는 것을 의미한다고 볼 수 있겠다.<br />
(이렇게 개체의 특징적인 부분, 또는 완성품을 만들어내는데 필요한 부분을 추려내는 것을 추상화라고 부른다.)

앞서 배운 기본적인 자료형이나, 제어문과 반복문의 내용을 떠올려보자.<br />
그렇다면 기본적인 main 클래스 하나만으로도 간단한 프로그램은 충분히 만들수 있다는 것을 알 수 있을 것이다.<br />
그러나 프로그램의 크기가 복잡도가 커진다면 단순히 main 클래스 하나만으로 만들기에는 적절하지도 않고, <br />설령 만들어낸다 해도 그 이후의 유지보수가 매우 어려워질 것이다.<br />
그런 것을 여러 객체로 나누어 프로그램의 구조 파악과 관리가 용이하게끔 구성하는 것이 <br />바로 객체 지향 프로그래밍이라고도 볼 수 있겠다.

또한 바로 그 객체들을 만들어내는 대에 핵심적인 역할을 하는 것이 바로 클래스라고도 할 수 있다.<br />
클래스는 객체를 만들어 내기 위한 일종의 설계도라고 볼 수 있다.<br />
클래스를 설계하고 나면, 이를 통해 우리가 일반적으로 변수를 만들듯이 클래스의 인스턴스, 즉 객체를 생성한다.<br />
객체와 인스턴스는 같은 대상을 의미한다고 볼 수 있다.<br />
인스턴스라는 말은 주로 클래스와 객체의 관계를 나타낼 때 쓰는 말이라고 보면 된다. <br />이를테면 A라는 클래스를 이용해 만든 객체는 A 클래스의 인스턴스라고 부른다.<br />
그렇다면 이제부터 클래스에 대해서 본격적으로 알아보도록 하자.

---

# 클래스의 기본 구성과 생성 및 사용 방법

## 클래스 생성 방법 및 기본적인 형태 (멤버 변수, 생성자, 메서드)

우선 **클래스**라는 것이 도대체 어떻게 생겨먹은 것인지, 또 어떻게 구성되어 있는지에 대해서 알아보자.<br />
클래스는 기본적으로 크게 3가지 요소로 구성되어 있는데, **클래스 멤버 변수**, **생성자**, 그리고 **메서드**이다.<br />
클래스를 작성한 후 이를 통해 객체(인스턴스)를 생성할 때는 new 키워드를 사용하여 생성한다.

```C#
class Car
{
    // 클래스 멤버 변수
    public int carNumber;
    public string carModel;


    // 생성자
    public Car(int carNumber, string carModel)
    {
        this.carNumber = carNumber;
        this.carModel = carModel;
    }

    // 메서드
    public void carInfo()
    {
        Console.WriteLine("차량 번호: " + carNumber);
        Console.WriteLine("차량 모델명: " + carModel);
    }
}
```

위와 같은 클래스를 작성하였다면, 클래스를 통해 인스턴스를 생성할 때는 아래와 같이 작성하면 된다.

```
[클래스 이름] [객체(인스턴스) 이름] = new [클래스 이름] (생성자 매개변수);
```

즉, 위의 Car 클래스를 통해 객체를 생성해보자면 아래와 같이 생성할 수 있는 것이다.

```C#
Car car = new Car(1234, "소나타");
```

위의 Car 클래스는 생성자에 carNumber와 carModel, 총 2개의 매개변수가 있기에 두 개의 매개변수를 넣은 것이다.<br />
아직은 위의 클래스 멤버 변수, 생성자, 메서드와 같은 형태들이 각각 무엇을 의미하는 것인지 잘 이해가 되지 않을 수 있다.<br />
클래스에서 객체(인스턴스)를 생성하는 방법만 이해했으면, 일단은 클래스는 대략적인 형태가 저렇다고만 이해해도 충분할 것이다.<br />
그럼 이제부터 위의 각 요소들에 대해서 더욱 자세히 알아보도록 하자.

---

### 클래스 멤버 변수

우선은 클래스 멤버 변수에 대해서 알아보자.<br />
클래스 멤버 변수는 클래스 안에 선언되는 변수들을 가리키는 말이다.
아래의 클래스 예시를 보도록 하자.

```C#
class Car
{
    // 클래스 멤버 변수 (인스턴스 변수)
    public int carNumber;
    public string carModel;
}
```

이 클래스 안에 선언된 두 개의 변수, 즉 

> public int carNumber, public string carModel

이 두 가지가 클래스 멤버 변수들이다. 
말 그대로 클래스 안에 선언된 변수를 의미하는 것이라고 이해하면 될 것이다.<br />
또한 이런 식으로 클래스 내부에 멤버 변수들만 있고, 생성자나 메서드가 없는 클래스를 **모델 클래스**라고 부른다.

클래스 멤버 변수는 다시 인스턴스 변수와 클래스 변수, 크게 두 가지로 분류할 수 있다.<br />
위의 예시로 작성한 두 변수들은 인스턴스 변수에 해당한다.<br />
각 변수의 생성 방법은 아래에서 설명하도록 하겠다.

#### 인스턴스 변수

인스턴스 변수는 사용하기 위해서는 반드시 클래스를 통해 객체를 생성해야하는 변수를 의미한다.<br />
인스턴스 변수의 생성 방법은 아래와 같다.

```
[접근 제한자] [자료형] [클래스 멤버 변수 이름];
```

접근 제한자에 대해서는 아래에서 좀 더 자세히 다뤄보도록 하겠다.<br />
우선 현재는 접근 제한자의 위치에 있는 것이 public 키워드라는 것만 알아두면 된다.

아래의 코드를 살펴보도록 하자.

```C#
class Car
{
    // 클래스 멤버 변수 (인스턴스 변수)
    public int carNumber;
    public string carModel;
}

static void Main(string[] args)
{
    Car car = new Car();

    car.carNumber = 1234;
    car.carModel = "그랜져";

    Console.WriteLine("차량 번호: " + car.carNumber);
    Console.WriteLine("차량 모델명: " + car.carModel);

    //실행 결과
    //차량 번호: 1234
    //차량 모델명: 그랜져
}
```

위와 같이, 인스턴스 변수인 carNumber와 carModel에 접근하기 위해서 <br />Car 클래스의 객체(인스턴스) car를 생성한 후,
carNumber와 carModel에 값을 할당했다.<br />
인스턴스 변수를 호출하려면 ``[인스턴스 이름].[인스턴스 변수]``로 호출하는 모습 또한 확인할 수 있었다.<br />
car 인스턴스를 생성하지 않은 상태에서는 carNumber이나 carModel에 접근할 수 있는 방법이 없다.

#### 클래스 변수

반대로, 클래스 변수의 경우, 객체(인스턴스)를 생성하지 않고서도 멤버 변수를 호출할 수 있다.<br />
아래와 같은 방법으로 생성한다.

```
[접근 제한자] static [자료형] [클래스 멤버 변수 이름] = [초기화 값];
```

인스턴스 변수에서 static 키워드가 더해졌다.<br />
또한, 클래스 변수는 클래스에서 곧바로 호출할 수 있기 때문에, 반드시 값을 초기화해줘야 한다.

아래의 클래스 예시를 보도록 하자.

```C#
class Car
{
    // 클래스 멤버 변수 (클래스 변수)
    public static int carNumber = 1111;
    public static string carModel = "null";
}

static void Main(string[] args)
{
    Car.carModel = "아반떼";

    Console.WriteLine("차량 번호: " + Car.carNumber);
    Console.WriteLine("차량 모델명: " + Car.carModel);

    //실행 결과
    //차량 번호: 1111
    //차량 모델명: 아반떼
}
```

이 경우, 위의 인스턴스 변수처럼
> Car car = new Car();

와 같은 객체(인스턴스) 생성 과정 없이 곧바로 Car 클래스를 통해 carNumber와 carModel 변수에 접근하는 모습을 볼 수 있다.<br />
클래스 변수를 호출하려면 ``[클래스 이름].[클래스 변수]``로 호출하는 모습도 확인할 수 있다.

클래스 멤버 변수 뿐만 아니라 메서드에도 static 키워드를 이용한 클래스 메서드 생성이 가능하다.<br />
이는 아래의 메서드 부분에서 살펴보도록 하겠다.

#### 접근 제한자

위의 예시들에서 클래스 멤버 변수 선언 시에, public 키워드가 있는 것을 보았을 것이다.<br />
그와 같은 키워드를 **접근 제한자** 라고 부른다.<br />
이름 그대로 해당 변수를 접근할 수 있는 권한(범위)을 설정하는 역할을 한다.

접근 제한자는 클래스 멤버 변수 뿐 아니라 생성자나 메서드에도 모두 사용된다.<br />
여기서는 3가지의 접근 제한자, public, private, protected에 대해서 알아보도록 하자.

1. 우선 **public** 키워드이다.<br />
public 키워드가 사용된 변수, 생성자, 메서드는 클래스 내부나 외부 등 모든 곳에서 접근할 수 있게 된다.

2. 그 다음은 **private** 키워드이다.<br />
private 키워드를 직접 입력하거나, 혹은 어떤 접근 제한자도 붙이지 않았을 경우, 자동으로 private 제한자가 설정된다.<br />
private 제한자가 적용된 변수, 생성자, 메서드는 오로지 클래스 내부에서만 사용할 수 있게 된다.<br />
프로그램 사용자가 함부로 접근하면 안되는 변수가 있을 시, private 제한자를 설정하여 해당 변수를 보호할 수 있다.

예를 들자면, 은행에 예금을 고객들이 마음대로 바꿔버릴 수 있다면 매우 위험할 것이다.<br />
그런 경우에는 예금액수를 저장하는 변수를 private 제한자로 보호할 수 있을 것이다.<br />
아래의 코드를 직접 작성해서 실행해보면 무슨 뜻인지 쉽게 알 수 있을 것이다.

```C#
class BankAccount
{
    private int depositAmount;
}

static void Main(string[] args)
{
    BankAccount account = new BankAccount();

    account.depositAmount = 1000000000; // 오류 발생 (보호 수준으로 인해 액세스 불가능)
}
```

private 제한자를 사용하고 있으므로 마음대로 건드릴 수 없다.<br />
이 외에도 이를테면, 게임을 진행하는데 있어 플레이어들이 마음대로 건드리면 문제가 발생할만한 수치,<br />
즉 캐릭터의 체력이나 공격력 등을 private 제한자로 보호할 수 있을 것이다.<br />
이렇듯 건드리면 여러모로 위험한 것들을 함부로 접근할 수 없도록 보호하는 것을 **캡슐화**라고 부른다.

다만 이러면 궁금증이 생길 수 있을 것이다.<br />
위의 예시의 경우, 어찌되었든 간에 은행 예금 액수를 저장하는 변수이므로, 분명 어떤식으로든 값을 대입해야 할 것인데,<br />
외부에서 접근할 수 없다면 도대체 어떻게 예금 액수를 저장할 수 있다는 말인가?<br />
그에 대한 답은 아래 클래스 메서드에 대한 설명의 속성 파트에서 겟터와 셋터를 참고하면 될 것이다.

3. 마지막으로 **protected** 키워드이다.<br />
protected 키워드가 적용된 경우, private과 같이 자신 클래스 내부에서만 사용할 수 있는 것에 더해서,<br />
해당 클래스를 상속받은 파생 클래스에서도 사용할 수 있게 된다.<br />
상속에 대해서는 아래 상속 파트에서 살펴보도록 하자.

---

### 클래스 생성자

이번에는 클래스 생성자에 대해서 알아보도록 하자.<br />
클래스 생성자란 클래스를 만들 때 호출하는 특별한 메서드이다.<br />
클래스 객체(인스턴스)를 선언할 때 생성자에 맞는 매개변수를 함께 초기화 하는 역할을 한다.<br />
아래의 예시 클래스를 보도록 하자.

```C#
class Car
{
    // 클래스 멤버 변수
    public int carNumber;
    public string carModel;


    // 생성자
    public Car(int carNumber, string carModel)
    {
        this.carNumber = carNumber;
        this.carModel = carModel;
    }
}
```

위의 주석에 적어놓았듯이, 이러한 클래스에서 생성자는

```C#
public Car(int carNumber, string carModel)
    {
        this.carNumber = carNumber;
        this.carModel = carModel;
    }
```
이렇게 생긴 부분을 의미한다.

클래스 생성자의 경우 몇가지 규칙이 존재한다.
1. 우선 생성자의 이름은 클래스의 이름과 같아야 한다. <br />
위의 클래스 이름이 Car이기 때문에, 생성자의 이름 또한 Car인 것을 확인할 수 있다.

2. 또한 생성자는 반환과 관련된 선언을 하지 않는다.<br />
일반적인 메서드와는 다르게, 생성자는 return 값을 가질 수 없다.

생성자가 존재하는 클래스는 객체(인스턴스)를 생성할 때, 해당 생성자에 맞는 매개변수를 가지고 생성해야 한다.<br />
예를 들어, 위의 생성자는 int형 carNumber와 string형 carModel 매개변수를 가지고 있으므로
생성 시에 아래와 같이 생성하면 된다.

```C#
Car car = new Car(1234, "소나타");
```

이렇게 작성하면 Car 클래스의 멤버 변수인 carNumber와 carModel에 각각 매개변수가 대입된 채로 생성되게 된다.

잠깐 덧붙이자면, 생성자에도 앞서 접근 제한자에서 언급한 private 제한자를 사용하는 경우가 있다.<br />
생성자에 private을 사용하면 인스턴스 생성이 불가능해지는데, 
클래스에 정적(static) 멤버밖에 없는 경우 이렇게 작성하기도 한다.<br />
팩토리 메서드 패턴이라는 것과 연관되어있다고도 하는데, 아직은 알아보기에는 이른 단계인 것 같다.

#### 생성자 오버로딩

생성자를 작성하다보면 문득 이런 생각이 들 수 있을 것이다.

```
객체를 생성할 때 항상 똑같은 정보를 줘야만 할까? 모르는 정보가 있는 경우에는 어떻게 할 것인가?
```

이런저런 이유로 인해 생성자 매개변수를 다르게 줘야 하는 일이 발생할 수도 있을 것이다.<br />
그런 상황에 대비하여 생성자는 오버로딩 기능을 사용할 수 있다.<br />
오버로딩은 이름은 같고, 매개변수는 다른 메서드를 만드는 것을 의미한다.

생성자 오버로딩을 하는 방법은 아래를 보도록 하자.

1. 우선은 단순히 생성자를 여러 개 적는 방법이 있다.<br />
비효율적이지만 가장 쉽게 적을 수 있는 방법이기는 하다.<br />
예를 들면 위의 Car 생성자를 적을 때, 차량 번호와 차량 모델명을 다 모를 때, <br />혹은 하나만 알 때로 나눠서 생성자를 만들고 싶다고 가정해보자.

```C#
public Car()
    {
    
    }

public Car(int carNumber)
    {
        this.carNumber = carNumber;
    }

public Car(string carModel)
    {
        this.carModel = carModel;
    }    

public Car(int carNumber, string carModel)
    {
        this.carNumber = carNumber;
        this.carModel = carModel;
    }
```

이런 식으로 적을 수 있을 것이다.
하지만 이러면 코드가 너무 의미없이 길어지고 지저분하게 보일 것이다.<br />
다른 개발자들과의 협업을 위해서는 코드를 더욱 간결하고 알기 쉽게 작성하는 것도 중요하다.

생성자를 깔끔하게 오버로딩 하기 위해서는 this라는 키워드를 사용하면 된다.

2. 아래는 위의 생성자 오버로딩을 this 키워드를 이용해 작성한 것이다.

```C#
public Car()
    {
    
    }

public Car(int carNumber) : this()
    {
        this.carNumber = carNumber;
    }

public Car(string carModel) : this()
    {
        this.carModel = carModel;
    }    

public Car(int carNumber, string carModel) : this(carNumber)
    {
        this.carNumber = carNumber;
        this.carModel = carModel;
    }
```

이런 식으로 작성하면 매개변수를 굳이 여러번 적지 않고서도 깔끔하게 생성자 오버로딩을 작성할 수 있다.<br />
생성자 매개변수 뒤에 오버로딩 할 생성자를 

```
: this(오버로딩할 연산자의 매개변수)
```

이와 같은 형식으로 삽입하면 된다.

---

### 클래스 메서드 (메소드)

메서드는 다른 언어에서 흔히 함수라고 부르는 것이라 보면 된다.<br />
자주 사용하는 기능을 메서드를 통해 간단하게 호출할 수 있도록 만드는 것이 기본 목적이라고 볼 수 있다.

예를 들어서, 계산기 기능을 구현해야 한다고 생각해 보자.<br />
그렇다면 우선 제일 간단한 사칙연산 기능부터 구현해야 할 것이다.<br />
아래의 클래스 Calculator에 더하기와 곱하기 기능을 각각 add와 multi 메서드로 구현한 것이다.

```C#
class Calculator
{
    public int add(int x, int y)
    {
        return x + y;
    }

    public int multi(int x, int y)
    {
        return x * y;
    }
}
```

그럼 지금부터 본격적으로 메서드에 대해서 알아보도록 하자.

#### 인스턴스 메서드

클래스 멤버 변수에 인스턴스 변수와 클래스 변수가 있었던 것처럼, 메서드 또한 클래스 메서드와 인스턴스 메서드가 있다.<br />
둘의 차이 또한 클래스 멤버 변수가 그랬듯이 static 키워드의 사용 유무이다.<br />
또한 인스턴스 메서드는 반드시 클래스에서 객체(인스턴스)를 생성하고 사용해야 한다는 점,<br />
클래스 메서드는 클래스에서 곧바로 메서드를 사용할 수 있다는 점 또한 클래스 멤버 변수와 유사한 형태를 갖는다.

인스턴스 매서드의 경우 바로 위에 적어놓은 Calculator 클래스의 매서드 add, multi가 바로 그 예시라고 볼 수 있다.<br />
그러므로 인스턴스 메서드는 아래와 같은 방식으로 만들면 된다는 것을 쉽게 알 수 있다.

```
[접근 제한자] [자료형] [메서드 이름] (매개변수) { 메서드 실행 내용 }
```

매개변수 없이 자체적으로 어떤 내용을 실행하는 메서드일 경우는 매개변수가 반드시 존재할 필요는 없다.<br />
또한 자료형이 void일 경우 반환값, 즉 return 값이 없어도 되나, 그 외 자료형일 경우 return을 적어줘야 한다.

```C#
class Calculator
{
    public int add(int x, int y)
    {
        return x + y;
    }

    public int multi(int x, int y)
    {
        return x * y;
    }
}

static void Main(string[] args)
{
    Calculator calculator = new Calculator();

    Console.WriteLine(calculator.add(2,5));
    Console.WriteLine(calculator.multi(2,5));
}
```

인스턴스 메서드를 활용하려면 **``[인스턴스 이름].[인스턴스 메서드](매개변수)``** 로 활용함을 쉽게 알 수 있다.


#### 클래스 메서드

클래스 메서드의 경우는 static 키워드를 사용하여 작성한다.
아래와 같은 방식으로 작성하면 된다.

```
[접근 제한자] static [자료형] [메서드 이름] (매개변수) { 메서드 실행 내용 }
```

클래스 멤버 변수에서 인스턴스 변수와 클래스 변수의 작성법 차이와 거의 유사하므로 이해하기 어렵지 않을 것이다.<br />
바로 앞서 만든 Calculator 클래스의 메서드들을 이번엔 클래스 메서드로 작성해보자.

```C#
class Calculator
{
    public static int add(int x, int y)
    {
        return x + y;
    }

    public static int multi(int x, int y)
    {
        return x * y;
    }
}

static void Main(string[] args)
{
    Console.WriteLine(Calculator.add(2,5));
    Console.WriteLine(Calculator.multi(2,5));
}
```

단, 클래스 메서드의 경우 여기서 주의해야 할 점이 있다.<br />
클래스 변수의 경우도 사실 마찬가지이지만, 클래스 메서드의 경우 프로그램을 실행하는 순간부터 준비된다.<br />
그렇기 때문에 클래스에서 객체(인스턴스)를 생성해야 하는 인스턴스 변수나 인스턴스 메서드를 클래스 메서드에서 사용할 수는 없다.<br />
클래스 메서드에서는 오로지 같은 클래스 메서드 및 클래스 변수만 사용할 수 있다.


#### 메서드 오버로딩

메서드 오버로딩의 경우 같은 이름을 가진 메서드를 서로 다른 매개변수를 통해서 사용하려 할 때 필요하다.<br />
이를테면 위의 Calculator 클래스의 add 메서드를 int형 뿐 아니라, <br />double형과 long형 또한 매개변수로 사용할 수 있도록 한다고 가정해보자.<br />
그렇다면 아래와 같이 작성하면 될 것이다.

```C#
class Calculator
{
    public int add(int x, int y)
    {
        return x + y;
    }

    public double add(double x, double y)
    {
        return x + y;
    }

    public long add(long x, long y)
    {
        return x + y;
    }

    public int multi(int x, int y)
    {
        return x * y;
    }
}
```


#### 속성 (겟터(Getter)와 셋터(Setter))

겟터와 셋터는 앞서 언급한 private 생성자에서 설명한 부분과 연관지어서 이해하면 된다.<br />
예를 들어서, 사용자의 나이를 입력받아야 하는 프로그램이 있다고 가정해보자.<br />
그런데 만약 사용자가 실수로, 혹은 고의로 나이를 음수로 입력했다면 어떻게 될까?<br />
아마 높은 확률로 프로그램에 오류가 발생하거나, 혹은 오류가 발생하지 않는다 해도 제대로 된 결과를 얻지 못할 것이다.

그렇기 때문에 클래스 멤버 변수의 값은 private 제한자로 함부로 접근하지 못하도록 하고,<br />
메서드를 이용해 private 변수를 간접적으로 변경하되, <br />제대로 된 값을 입력하지 않으면 값을 변경하거나 입력받지 않게끔 만드는 것이다.<br />
이것이 바로 **셋터(Setter)** 메서드이다.

그리고 private 변수를 다시 필요한 때에 돌려줄 수 있도록 메서드를 통해 간접적으로 돌려주는 것이 바로 **겟터(Getter)** 메서드이다.

셋터와 겟터라는 명칭은 개발자들간의 암묵적 약속이므로 해당 명칭을 이용하는 것이 좋다.

나이를 입력받는 클래스를 직접 작성해보도록 하자.

```C#
class AgeInput
{   
    // private 인스턴스 변수
    private int age;

    public AgeInput(int age)
    {
        if (age > 0)
        { 
        this.age = age;
        }
        else {Console.WriteLine("나이 값을 다시 입력해주세요.")}
    }

    // 셋터(Setter)
    public void SetAge(int age)
    {
        if (age > 0)
        {
            this.age = age;
        }
        else {Console.WriteLine("나이 값을 다시 입력해주세요.")}
    }

    // 겟터(Getter)
    public void GetAge()
    {
        return age;
    }

    public void PrintAge()
    {
        Console.WriteLine("나이: "+age);
    }
}
```

C#에서는 겟터와 셋터를 조금 더 편리하게 만들 수 있는 '속성(프로퍼티:Property)'이라는 방법 또한 제공한다.<br />
주로 작성하는 방법은 아래와 같다.

```C#
private [자료형] [변수 이름]
public [자료형] [속성 이름]
{
    get {return [변수 이름];}
    set {[변수 이름] = value;}
}
```

보통 속성의 이름은 해당 변수의 이름 제일 앞글자를 대문자로 작성한 것이다.<br />
이를테면 변수 age의 속성 이름은 Age로 작성하면 된다.<br />
사용하는 방법은 아래와 같다.

```C#
// 셋터(Setter)
[인스턴스 이름].[속성 이름] = [값]

// 겟터(Getter)
[인스턴스 이름].[속성 이름]
```

즉, 위의 AgeInput 클래스를 속성을 이용해 작성한다면 아래와 같다.

```C#
class AgeInput
{   
    // private 인스턴스 변수
    private int age;
    // 속성(Property): 겟터와 셋터
    public int Age
    {
        get { return width; }
        set 
        { 
            if (age > 0) { age = value; }
            else { Console.WriteLine("나이 값을 다시 입력해주세요."); }
        }
    }

    public AgeInput(int age)
    {
        Age = age;
    }

    public void PrintAge()
    {
        Console.WriteLine("나이: "+age);
    }
}
```

속성을 더욱 간단하게 생성하는 아래와 같은 방법도 있다.

```C#
public int Age {get; set;}
```

하지만 이렇게 사용하면 속성을 사용하는 것이나, 변수를 사용하는 것이나 큰 차이가 없다고 한다.


#### 소멸자

소멸자는 생성자와 대척점을 이룬다. <br />
즉, 생성자가 인스턴스를 생성할 때 실행하는 메서드라면, 소멸자는 인스턴스가 소멸될 때 실행된다.<br />
C#은 JAVA와 비슷하게 쓰레기 수집기(Garbage Collector)를 실행하여 더 이상 사용되지 않을 것이 확실한 객체들을 소멸시킨다.

소멸자의 형태는 다음과 같다.

```
~[클래스 이름]() { 소멸자에서 실행할 내용 }
```

---

# 기본 변수와 참조 변수의 차이점

클래스까지 배움으로서 C#의 대표적인 자료형에 대해서는 거의 다 알아보았다고 할 수 있다.<br />
물론 아직 배워야 할 것이 더 남았지만, 이쯤에서 이러한 자료형들의 특징을 정리해보도록 하자.<br />
JAVA와 같은 언어에서도 비슷하지만, C#의 자료형은 크게 **기본 변수**와 **참조 변수**로 나눌 수 있다.

기본 변수, 즉 값은 말 그대로 기본적인 자료형들을 의미한다.<br />
이를테면 앞서 배웠던 int, float, long, double등의 자료형들을 의미한다.

참조 변수는 클래스로 만들어진 객체들을 의미한다.<br />
문자열, 즉 string 또한 클래스 객체이므로 참조 변수이며, 기타 클래스로 생성하는 인스턴스들 또한 참조 변수이다.

이들의 차이점은 데이터를 어떤 방식으로 저장하느냐에 있다.<br />
컴퓨터 메모리 영역은 크게 4가지 영역으로 나눌 수 있는데, 이 중에서도 **스택(stack)**과 **힙(heap)**이라 불리는 영역이 있다.<br />
(나머지 두 영역인 **코드(code)**와 **데이터(data)**는 각각 명령어를 읽어들여 저장하는 영역과 정적/전역 변수를 저장하는 영역이다.)

스택의 경우는 지역 변수와 매개 변수가 저장되는 영역이며, <br />
힙은 동적으로 할당 (필요에 따라 할당) 되는 변수, 즉 클래스와 같은 가변형 데이터들이 저장되는 영역이다.

기본 변수는 스택에, 참조 변수는 힙에 저장되게 된다.<br />
보다 정확히 말하자면 참조 변수는 스택과 힙을 모두 사용한다.

기본 변수의 경우는 스택에 값을 그대로 저장한다.<br />
예를 들어서, int 자료형 변수 a를 선언해서 10이라는 값으로 초기화했다면, <br />스택 영역에는 int a = 10으로 그대로 저장되어 있을 것이다.<br />
그렇기 때문에 다음과 같은 예시를 본다면, 두 변수는 서로 다른 값을 저장하게 된다.

```C#
int a = 10;
int b = a;
b = 20;
Console.WriteLine(a);

// a의 값: 10, b의 값: 20
```

b에 a의 값을 대입한 후에 b의 값을 변경한다 해도, <br />a와 b는 스택 영역에 각각 별개로 저장되어 있기 때문에 a의 값은 그대로 10으로 유지된다.


그러나 참조 변수의 경우는 다르다.<br />
이를테면 Car 클래스의 인스턴스 car를 만들었다고 가정해보자.<br />
그렇다면 힙 영역에 객체(인스턴스)가 저장되며, car는 힙에 생성된 실제 객체의 주소를 저장하게 되어 <br />그 주소값이 스택 영역에 저장되게 된다.<br />
그렇기 때문에 다음과 같은 예시를 본다면, 두 객체(인스턴스)는 같은 객체를 지정하게 된다.

```C#
Car car1 = new Car();
Car car2 = car1;

car1.carNumber = 1234;
car2.carNumber = 5678;

Console.WriteLine(car1.carNumber);

//car1.Number의 값: 5678, car2.carNumber의 값: 5678
```

참조 변수는 힙 영역에 있는 실제 객체의 주소값을 저장한다고 했다.<br />
그렇기 때문에 Car 클래스 객체(인스턴스)의 주소값을 저장한 car1을 car2에 대입하면, 둘은 같은 주소값을 가지게 된다.<br />
그렇다는 의미는 곧 car1과 car2는 같은 객체를 가르키고 있다는 것이다.<br />
그래서 car2의 멤버 변수 carNumber의 값을 바꿈으로 인해서 car1의 멤버 변수의 값도 똑같이 바뀌게 된다는 것이다.

---


# 클래스의 상속과 다형성

마지막으로 **상속**과 이를 통한 **다형성**의 구현에 대해서 알아보자.<br />
상속과 다형성이야말로 클래스의 진정한 존재 이유이자 객체 지향 프로그래밍의 꽃이라고도 불릴만한 부분이다.<br />
그만큼 객체 지향 프로그래밍 언어들은 상속과 다형성에 대해서 강조를 많이 한다.<br />
이는 후에 다룰 인터페이스 등과도 연계되는 내용이니 제대로 정리하고 넘어가도록 하자.

## 클래스 상속

**클래스 상속**에 대해서 정리해보도록 하자.<br />
클래스 상속이란 말 그대로 부모 클래스가 자식 클래스에게 물려주는 것을 의미한다.

흔히 나오는 예시이지만, 이를테면 강아지가 고양이와 같은 동물들을 클래스로 정의한다고 가정해보자.<br />
그렇다면 강아지와 고양이를 각각 따로 클래스로 정의하는 것도 물론 가능하지만, <br />강아지와 고양이 사이에 공통점을 찾을 수 있을 것이다.<br />
이를테면 네 발로 걸어다닌다는 것과 같은 공통점 말이다. <br />밥을 먹거나, 잠을 자거나, 나이를 먹어가는 당연한 것들 또한 공통점이라고 볼 수 있겠다.<br />
하지만 강아지와 고양이 사이에는 차이점도 당연히 존재한다. 이를테면 강아지는 '멍멍'하고 짖지만, 고양이는 '야옹'하고 운다.<br />
그렇다면 강아지와 고양이 사이의 공통점을 우선 클래스로 구현한 다음, <br />강아지만의 특징을 강아지 클래스로 따로 만들고, <br />고양이만의 특징을 고양이 클래스로 따로 만든다면
중복되는 내용을 굳이 2번 작성하지 않아도 될 것이다.

클래스 상속은 이와 같이 더욱 효율적인 프로그래밍을 위해 만들어진 기술이다.<br />
또한 상속은 아래에서 곧 설명할 **다형성**과도 큰 관련이 있다.

우선은 C#에서 클래스 상속을 하려면 어떻게 코드를 작성해야 하는지부터 알아보도록 하자.<br />
아래의 간단한 예시 코드를 보자.

```C#
class Animal
{
    public int Age {get; set;}
    
    public Animal() { this.Age = 0;}

    public void Eat()
    {
        Console.WriteLine("밥을 먹습니다.");
    }
    public void Sleep()
    {
        Console.WriteLine("잠을 잡니다.");
    }
}
```

위와 같이 강아지와 고양이의 공통점을 담은 부모 클래스 Animal을 작성했다고 해보자.<br />
그렇다면 자식 클래스 Dog와 Cat을 아래와 같이 작성할 수 있을 것이다.<br />
클래스 상속을 받을 때는 ':'을 이용하여 상속받는다.

```C#
class Dog : Animal // Dog : Animal로 Dog 클래스가 Animal을 상속받음을 나타냄
{
    public void Bark() {Console.WriteLine("멍멍 짖습니다.");}
}

class Cat : Animal // Cat : Animal로 Cat 클래스가 Animal을 상속받음을 나타냄
{
    public void Meow() {Console.WriteLine("야옹 웁니다.");}
}
```

이렇게 자식 클래스를 생성하면, 자식 클래스의 객체(인스턴스)를 생성했을 때, 자식 클래스가 부모 클래스의 멤버에 접근할 수 있다.<br />
단, 접근 제한자가 public이거나 protected인 멤버에 한정한다. <br />위의 접근 제한자의 내용을 다시 한번 떠올려보자.

```C#
Dog dog = new Dog()

dog.Eat()
dog.Sleep()
dog.Bark()
```

이와 같은 식으로 부모 클래스의 멤버에도 접근할 수 있다.

클래스 상속 시에 유의해야 할 점은, 클래스를 상속하여 자식 클래스의 객체(인스턴스)를 생성할 시,<br />
부모 클래스의 생성자가 먼저 실행된 후 자식 클래스의 생성자가 실행된다는 점이다.<br />
만약 자식 클래스를 생성하며 부모 클래스의 생성자에 특정한 매개변수를 주어야 할 경우에는 **base** 키워드를 이용할 수 있다.

```C#
class Animal
{
    public Animal() { Console.WriteLine("부모 생성자"); }
    public Animal(string animal) { Console.WriteLine("부모 생성자" + animal); }
}

class Dog : Animal 
{
    public Dog() : base()
    {
        Console.WriteLine("자식 생성자");
    }
}

class Cat : Animal
{
    public Cat() : base(animal)
    {
        Console.WriteLine("자식 생성자");
    }
}
```

부모 클래스의 생성자에 특정한 매개변수를 넣고 싶을 경우에는 <br />base 키워드의 매개변수로 해당 자료형과 같은 매개변수를 전달해주면 된다.

또한 클래스 변수(static)의 경우는 클래스가 상속되어도 부모 클래스와 자식 클래스가 서로 공유한다는 점을 주의하도록 하자.

## 클래스 다형성

상속에 대해서 알아보았으니 곧바로 다형성에 대해서 알아보도록 하자.<br />
다형성이란 하나의 클래스가 여러 형태로 변환될 수 있는 성질이라고 한다.<br />
이것이 무슨 뜻이냐 하면, 부모 클래스를 선언하고 거기에 해당 클래스의 자식 클래스들을 대입할 수 있다는 얘기이다.<br />
위의 Animal - Dog, Cat 클래스를 예시로 들어본다면 아래와 같다.

```C#
Animal dog = new Dog();
Animal cat = new Cat();
```

다만 이렇게 생성하면 dog나 cat 모두 Animal 클래스로 생성한 것이기 때문에 Dog나 Cat 클래스에 정의된 멤버를 사용할 수는 없다.<br />
dog나 cat이 Dog나 Cat에 정의된 멤버를 사용하려면 해당 클래스로 임시로 자료형 변환을 해야한다.<br />
자료형 반환을 하는 방법은 아래와 같다.

```
(([자료형 반환을 할 클래스])[인스턴스]).[자료형 반환을 할 클래스의 멤버]
```

예시를 들자면 아래와 같다.

```C#
((Dog)dog).Bark();

// 실행 결과: 멍멍 짖습니다.
```

이런 자료형 변환을 반복문이나 조건문과 같은 다른 문법과 연계해서 사용하기 위해 필요한 키워드가 있는데,<br />
그것이 바로 **is**나 **as**와 같은 키워드이다.

**is** 키워드는 어떠한 객체가 어떤 클래스의 인스턴스인지를 알아내기 위해 사용하는 키워드로, 아래와 같이 사용한다.

> 객체 is 클래스

```C#
dog is Dog
cat is Cat
```

해당 객체가 클래스의 인스턴스가 맞으면 True를, 아니면 False를 반환한다.

**as** 키워드는 앞서 언급한 자료형 변환을 더욱 간단하게 해주는 키워드라고 보면 된다.<br />
앞선 자료형 변환 방법과의 차이점이라면, as 키워드는 자료형 변환에 실패해도 예외를 발생시키지 않고 null값을 돌려준다는 점이다.<br />
예외에 대해서는 후에 정리해보도록 하겠다.<br />
아래와 같이 사용한다.

> 객체(인스턴스) 변수 as 클래스

```C#
dog as Dog
cat as Cat
```

이를 이용한 멤버 호출은 위의 자료형 변환과 비슷하다.

```C#
(dog as Dog).Bark();
(cat as Cat).Meow();
```

## 섀도잉, 하이딩 및 오버라이딩

이번에는 클래스 상속을 할 때 유의해야 할 내용인 **섀도잉**, **하이딩** 및 **오버라이딩**에 관해 알아보자.

### 섀도잉

**섀도잉**의 경우는 변수의 이름이 겹쳐서 특정 변수가 다른 변수를 가려버리는 것을 의미한다.<br />
아래의 코드를 살펴보자.

```C#
public static int number = 100;

static void Main(string[] args)
{
    int number = 1000;
    Console.WriteLine(number);

    //실행 결과: 1000
}
```

이와 같이, static 변수 number가 이미 100으로 초기화 되었음에도, <br />
main 안의 이름이 같은 변수 number를 1000으로 초기화하자 1000이 결과값으로 나오는 모습을 볼 수 있다.<br />
보통 호출할 때 거리가 더 가까운 변수를 호출하게 된다고 한다.

### 하이딩

**하이딩**의 경우는 클래스 상속 시에 동일한 이름으로 멤버를 만들 경우 일어난다.<br />
즉, 클래스 상속 시에 일어나는 섀도잉이라고 생각하면 이해가 쉽지 않을까 싶다.

```C#
class Parent
{
    public int variable = 100;
}

class Child : Parent
{
    public string variable = "hiding";
}

static void Main(string[] args)
{
    Child child = new Child();
    Console.WriteLine(child.variable);

    //실행 결과: hiding
}
```

메서드 또한 같은 방식으로 하이딩이 일어난다.<br />
만약 숨겨진 부모 멤버를 호출하고 싶다면 위에서 다룬 자료형 변환을 이용하여 호출하면 된다.<br />
위의 코드를 작성하면 경고 메세지가 노출되는데, 이럴 경우 아래와 같이 new 키워드를 붙여주면 하이딩 경고가 발생하지 않는다.

```C#
class Parent
{
    public int variable = 100;
}

class Child : Parent
{
    public string new variable = "hiding"; // new 키워드 사용
}

static void Main(string[] args)
{
    Child child = new Child();
    Console.WriteLine(child.variable);

    //실행 결과: hiding
}
```


### 오버라이딩

이번에는 **오버라이딩**에 관해서 정리해보자.<br />
오버라이딩은 하이딩과 비슷하지만 다른 개념으로, 부모 클래스의 메서드를 자식 클래스에서 재구현하는것을 의미한다.<br />
하이딩과 같은 형태로 메서드를 작성하되, **virtual**과 **override** 키워드를 사용하면 된다.<br />
오버라이딩을 한 메서드는 완전히 덮어씌워져서, 자료형 변환을 한다 해도 오버라이딩된 자식 클래스의 메서드가 호출된다.

오버라이딩의 대상이 될 메서드에는 virtual 키워드를 사용하고, 오버라이딩 하는 메서드는 override 키워드를 사용하면 된다.

```C#
class Parent
{
    public virtual void Method()
    {
        Console.WriteLine("부모 메서드");
    }
}

class Child : Parent
{
    public override void Method()
    {
        Console.WriteLine("자식 메서드");
    }
}

static void Main(string[] args)
{
    Child child = new Child();
    
    child.Method();
    ((Parent)child).Method();

    // 실행 결과
    // 자식 메서드
    // 자식 메서드
}
```

자료형 변환을 했음에도 자식 메서드만 2번 호출됨을 확인할 수 있다.

클래스 상속 및 메서드 오버라이딩과 관련된 키워드를 더 알아보도록 하자.<br />
그것은 바로 **sealed** 키워드와 **abstract** 키워드이다.

우선 **sealed** 키워드의 경우 클래스나 메서드 앞에 표기함으로서,
해당 클래스의 상속이나 메서드의 오버라이딩을 막는 역할을 한다.<br />
sealed라는 단어의 뜻 그대로 클래스나 메서드를 밀봉해버리는 것이다.

위의 오버라이드 예시를 조금만 수정해보도록 하자.

```C#
// 클래스와 메서드 앞에 sealed 키워드 사용
sealed class Parent
{
    sealed public void Method(){}
}

class Child : Parent // 상속 불가능
{
    public override void Method(){} // 오버라이딩 불가능
}

static void Main(string[] args)
{
    Child child = new Child();
    
    child.Method();
}
```

**abstract** 키워드의 경우는 반대로 해당 클래스나 메서드를 반드시 상속할 것을 강요한다.<br />
abstract라는 단어의 뜻 그대로, 해당 클래스나 메서드는 추상적인 상태이므로
반드시 구체화 시킬것을 요구하는 것이다.

abstract로 만든 클래스나 메서드, 즉 추상 클래스나 메서드는 어차피 상속으로 구체화시켜야 하기 때문에,<br />
해당 클래스로 객체(인스턴스)를 만들거나, 메서드의 내용을 적는 것이 불가능해진다.

위의 예시를 abstract로 바꿔 살펴보자.

```C#
// 클래스와 메서드 앞에 abstract 키워드 사용
abstract class Parent
{
    public abstract void Method(); //abstract 메서드는 중괄호 없이 곧바로 세미콜론(;) 사용
}

class Child : Parent
{
    public override void Method(){} // 오버라이딩 (하지 않았을 경우 오류 발생)
}

static void Main(string[] args)
{
    Child child = new Child();
    
    child.Method();
}
```

또한, 위의 예시를 보면, override 키워드는 사용했는데, virtual 키워드는 사용하지 않았음을 확인할 수 있다.<br />
그 이유는 어차피 abstract 키워드 자체가 상속을 강요하는 것이기 때문에 virtual 키워드를 굳이 적을 필요가 없기 때문이다.<br />
virtual 키워드는 자체적인 내용을 가지고 있으면서도 상속이 가능하고, <br />
abstract는 이름만 붙여진 껍데기를 통해 반드시 구체화를 시킬 것을 강요하는 차이가 있다고 보면 될 것이다.