---
sidebar_position: 1
tags: [C#, Unity]
---

# Unity를 위한 기본 문법 1

**유니티**는 기본적으로 **C#**을 사용해서 스크립트를 작성한다.<br />
그렇기 때문에 유니티를 잘 다루기 위해서는 C#에 대한 기본적인 이해가 필수적이다.<br />
우선 C# 문법과 기본 개념에 대해서 정리한 후, 유니티만의 문법을 정리하도록 할 것이다.

한빛아카데미의 'C# 프로그래밍 (저자 윤인성)' 책을 읽으며 내용을 정리한 것임을 미리 밝힌다.
그 외 인터넷 검색 자료들 또한 참고했다.

---

## 기본 자료형과 자료형 변환

### 기본 자료형

C#의 자료형은 다른 프로그래밍 언어, 특히 C 계통의 언어들과 거의 유사한 구조를 띄고 있다.<br />
**정수형, 실수형, 문자, 문자열**이 바로 그것이며, 사용하는 자료형 또한 거의 유사하다.

#### 정수형

정수 자료형은 이미 우리에게 익숙한 키워드인 **int**와 **long**을 사용한다.

|자료형|자료형크기|표현범위|
|:---:|:---:|:---:|
|sbyte|1바이트|-128 ~ 127|
|byte|1바이트|0 ~ 255|
|short|2바이트|-32,768 ~ 32,767|
|int|4바이트|-2,147,483,648 ~ 2,147,483,647|
|long|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

여기에서 표현 범위는 전혀 외울 필요가 없다.<br />
다른 언어와 마찬가지로 int와 long의 최대/최소값을 상수로 제공하기 때문에 손쉽게 최대/최소값을 불러올 수 있다.<br />
아래와 같이 **'자료형.MaxValue'로 최대값**을, **'자료형.MinValue'로 최소값**을 불러올 수 있다.

```C#
Console.WriteLine(int.MaxValue);
Console.WriteLine(long.MinValue);
```

다만 주의해야 할 점은, 해당 표현 범위를 넘어서게 되면 오버플로우(overflow) 또는 언더플로우(underflow)가 발생하여, <br />전혀 의도치 않았던 값을 얻게 될 수도 있다는 점이다.<br />
그러므로 항상 자신이 표현하고자 하는 수의 범위가 어디까지일지를 생각해서 자료형을 정해야 한다.

또한 기존 C언어에 존재하는 **unsigned 자료형** 또한 존재하는데,<br />
이 자료형은 음수 범위를 표현할 필요가 없을 때 더 넓은 양수 범위를 표현할 수 있게 해준다.<br />
예를 들자면, unsigned int 자료형은 0부터 4,294,967,295까지의 수를 저장할 수 있다.<br />
unsigned long 자료형의 경우는 0부터 18,446,744,073,709,551,615까지의 수를 저장할 수 있다.<br />
unsigned int, unsigned long을 매번 쓰기는 길기 때문인지 각각 **uint**와 **ulong** 키워드로 사용할 수 있다.<br />
short 자료형 또한 unsigned short 형태가 존재하며, **ushort** 키워드로 사용할 수 있다.

```C#
uint unsignedInt = 4147483647;
ulong unsignedLong = 11223372036854775808;
ushort unsignedShort = 65535;
```

#### 실수형

실수 자료형 또한 이미 익숙할 키워드인 **float**와 **double**을 사용한다.

|자료형|자료형크기|표현범위|
|:---:|:---:|:---:|
|float|4바이트|±1.5 x 10^−45 ~ ±3.4 x 10^38|
|double|8바이트|±5.0 × 10^−324 ~ ±1.7 × 10^308|
|decimal|16바이트|±1.0 x 10^-28 ~ ±7.9228 x 10^28|

**decimal** 자료형의 경우 보다 정확한 표현을 위해서 사용하는 자료형이라고 하는데,<br />
이를테면 0.1의 경우 float나 double로는 정확히 표현할 수 없지만, decimal은 가능하다고 한다.<br />
다만, 용량이 훨씬 크기 때문에 성능 최적화가 목적이라면 사용하지 않는 편이 좋다고 한다.

#### 문자형

문자 자료형은 **char** 키워드를 사용한다.<br />
주의할 점은 C언어에서는 char가 1바이트를 사용했지만, C#에서는 2바이트를 사용한다는 점이다.<br />
문자는 작은 따옴표(')를 이용해 글자를 감싸서 표현한다.

`char a = 'a';`

#### 문자열

문자열 자료형은 **string** 키워드를 사용한다.<br />
문자열은 큰따옴표(")를 사용해서 문자열 전체를 감싸서 표현한다.<br />
문자열 안에서 큰따옴표를 사용하고 싶은 경우에는 이스케이프 문자(`\`)를 사용해서 표현할 수 있다.

`string message = "안녕하세요";`

참고로 덧붙이는 자주 사용되는 이스케이프 문자는 아래와 같다.

|이스케이프 문자|설명|이스케이프 문자|설명|
|:---:|:---:|:---:|:---:|
|`\t`|수평 탭|`\\`|역슬래시|
|`\n`|행 바꿈|`\*`|큰따옴표|

또한, 문자열의 경우 문자열변수[인덱스]를 이용해 문자열의 해당 인덱스에 해당하는 문자만을 출력할 수도 있다.

```C#
Console.WriteLine(message[3]); //실행 결과: 세
```


#### 불(bool) 자료형

**불(bool)** 타입 자료형은 오직 두 가지 중 하나만의 값을 갖는다.
그것은 바로 '참(True)' 또는 '거짓(False)'이다.<br />
참 또는 거짓을 불 타입 변수에 그대로 대입할 수도 있으나, <br />아래와 같이 연산 결과가 참인지 거짓인지에 따라서도 불 타입 변수의 값이 달라지기도 한다.

```C#
bool one = 10 < 0;
bool other = 20 < 100;
```

이 경우, one의 연산 결과는 거짓이므로 one의 값은 False가 된다.<br />
그러나 other의 연산 결과는 참이므로 other의 값은 True가 된다.<br />
불 자료형의 경우 조건문에서 많이 쓰이므로 잘 알아두는 것이 좋다.


#### sizeof 연산자와 GetType() 메서드

위의 자료형의 크기를 알고 싶다면 **sizeof** 연산자를 사용할 수 있다.<br />
아래와 같이 'sizeof(자료형)'의 형태로 표현하면 해당 자료형의 크기가 출력된다.

```C#
Console.WriteLine("결과: " + sizeof(int));
```

또한, 어떤 변수의 자료형이 무엇인지 알고 싶을때는 **GetType()** 메서드를 사용할 수 있다.<br />
예를 들면 아래와 같이 사용한다.

```C#
int _int = 273;
Console.WriteLine(_int.GetType());
```

#### var 키워드

C#에서는 **var** 키워드를 통해 변수의 자료형을 자동으로 지정할 수 있다.<br />
단, var 키워드를 사용하려면 아래 두 가지의 조건을 충족해야 한다.

1. 지역 변수로 선언해야 한다.
2. 변수를 선언함과 동시에 초기화 해야 한다.

이 두 가지 조건을 충족했을 경우, var 키워드는 아래와 같이 사용할 수 있다.

```C#
var number = 100;
```

이렇게 사용했을 경우, var 키워드는 int 자료형이 되는 것이다.<br />
다만, 이렇게 var 키워드를 사용해서 초기화 한 number 자료형에 이후에 다른 자료형을 대입할 수는 없다.<br />
예를 들자면 아래와 같다.

```C#
var number = 100;
number = "변경";
```

이와 같은 코드는 오류가 발생한다.<br />
처음에 number 변수에 100을 대입함으로서 var 키워드가 int형이 된 꼴인데, <br />
int형 변수에 문자열을 대입할 수는 없는 노릇이니 당연한 결과라고 할 수 있다.

또한 var 키워드는 메서드의 반환형이나, 매개변수로 사용이 불가능하며, 클래스 멤버 변수로도 사용할 수 없다.
메서드나 클래스 멤버 변수에 대해서는 기본 문법 3편의 클래스에 관한 내용을 참고하도록 하자.

#### const 키워드

const는 상수를 생성할 때 사용한다.<br />
상수는 값을 변경할 일이 없거나, 또는 값을 변경해서는 안되는 수를 만들 때에 사용한다.<br />
다음과 같이 변수 앞에 const 키워드를 사용하면 간단하게 상수를 만들 수 있다.

```C#
const double PI = 3.141592;
```

또한, const는 기본적으로 전역 변수(static)의 특징을 갖게 되니 참고하도록 하자.

#### nullable 키워드

nullable 키워드는 일반 자료형을 null값으로 초기화 할 수 있도록 만들어주는 키워드이다.
무슨 뜻이냐 하면, 일반적으로 int형과 같은 자료형들은 null로 초기화가 불가능하다.
즉, 아래와 같이 적을 수 없다.

```C#
int num = null; // 에러 발생
```

하지만 nullable 키워드를 사용하면 다음과 같이 null로 초기화가 가능하다.
nullable 키워드는 아래와 같이 사용한다.

```C#
[자료형]? [변수 이름] = [초기화 값];
```

이를 통해 위의 변수 num을 nullable 키워드로 작성하면 아래와 같이 사용할 수 있다.

```C#
int? num = null;
```

물론 num은 일반 자료형처럼 null값이 아닌 값으로 초기화도 가능하다.
이후 다시 null값으로 값을 변환해도 문제가 없다.

```C#
int? num = 100;
num = null;
```

nullable 키워드를 이용하여 아래와 같은 연산도 가능하다.

```
[변수] ?? [변수]
```

위 연산의 경우, 만약 앞의 변수가 null이라면 결과로 뒤의 변수를, null이 아니라면 앞의 변수를 그대로 반환한다.
아래는 ?? 연산의 예시이다.

```C#
int? num1 = null;
int num2 = 100;

int result = num1 ?? num2;
Console.WriteLine($result: "{result}");

// 실행 결과: 100
```

result에 num1 ?? num2 연산의 경우, num1이 null이므로 num2를 result에 대입하게 된다.

---

### 연산자

C#의 연산자는 C 계통 언어와 거의 일치한다고 볼 수 있다.<br />
연산자는 크게 사칙 연산자, 비교 연산자와 논리 연산자, 
또는 단항 연산자, 이항 연산자, 삼항 연산자로 구분할 수 있다.

이 때, 삼항 연산자는 바로 뒤에 정리할 조건문과 동일한 기능을 하기 때문에, 
if문을 정리하면서 함께 다루도록 할 것이다.

우선은 단항 연산자와 이항 연산자에 해당하는 **사칙 연산자**, **비교 연산자**, **논리 연산자**를 살펴보도록 하자.

**사칙 연산자**의 경우, 누구나 기초적으로 다 알고 있는 바로 그 사칙 연산에 쓰이는 연산자들이다.<br />
덧붙여서 나눗셈 후 나머지를 돌려주는 나머지 연산자도 있다.

|연산자|설명|
|:---:|:---:|
|+|덧셈 연산|
|-|뺄셈 연산|
|*|곱셈 연산|
|/|나눗셈 연산|
|%|나머지 연산|

편의성을 위한 **복합 대입 연산자**도 존재하는데, 위의 사칙 연산자 뒤에 '='을 붙이면 된다.

|연산자|설명|
|:---:|:---:|
|+=|덧셈 연산|
|-=|뺄셈 연산|
|*=|곱셈 연산|
|/=|나눗셈 연산|
|%=|나머지 연산|

이럴 경우의 결과는 아래와 같다.

```C#
int output = 0;
output += 50; // output = output + 50;
output += 100; // output = output + 100;

Console.WriteLine(output); //실행 결과: 150
```

즉, 어떠한 값에 자신 스스로를 포함한 연산을 할 때 복합 연산자를 사용하면 편리하다.

순차적인 덧셈과 뺄셈을 편리하게 해 주는 **증감 연산자**도 존재한다.

|연산자|설명|
|:---:|:---:|
|++|덧셈 연산|
|--|뺄셈 연산|

이 연산자는 변수의 앞 또는 뒤에 배치하는 순서에 따라 결과값이 달라진다.<br />
변수의 앞에 배치하면 연산 후에 변수를 돌려주고,
변수의 뒤에 배치하면 변수를 돌려주고 연산한다.

덧셈 연산자의 경우, 덧셈 뿐만 아니라 아래 언급할 문자열 변환 또는 문자열 연결에도 쓰이니 참고하도록 하자.

그 다음은 **비교 연산자**와 **논리 연산자**이다.
비교 연산자와 논리 연산자의 경우, 결과를 불(bool) 값으로 돌려준다.

우선은 **비교 연산자**이다.

|연산자|설명|
|:---:|:---:|
|==|같다|
|!=|다르다|
|>|왼쪽 값이 크다|
|<|오른쪽 값이 크다|
|>=|왼쪽 값이 크거나 같다|
|<=|오른쪽 값이 크거나 같다|

**논리 연산자**의 경우는 다음과 같다.

|연산자|설명|
|:---:|:---:|
|!|논리 부정 연산자|
|&#124;&#124;|논리합 연산자|
|&&|논리곱 연산자|

논리 부정 연산자의 경우 해당 논리값의 반대값을 돌려준다.<br />
이를테면, 논리 결과가 True인 값에 논리 부정 연산자를 사용하면 False가 된다.

논리합 연산자는 두 가지의 값 중 하나가 True이면 값이 True가 된다.<br />
논리곱 연산자는 두 가지의 값이 모두 True여야 값이 True가 된다.

```C#
Console.WriteLine(!true); //실행 결과: False
Console.WriteLine((50>100)||(100>50)); //실행 결과: True
Console.WriteLine((150>100)&&(100>50)); //실행 결과: True
```

---


### 자료형 변환

#### 입력과 출력

C#에서 출력 메서드는 위의 내용에서 알 수 있듯이, Console 클래스의 **WriteLine()** 메서드를 사용한다.<br />
클래스 개념은 후에 정리하도록 할 것이며, 일단은 Console.WriteLine() 메서드로 화면에 출력한다고만 알면 된다.<br />
WriteLine()의 경우는 자동으로 개행(줄바꿈)을 실행해주는데, **Write()** 메서드의 경우는 줄바꿈이 일어나지 않는다.

```C#
Console.WriteLine("Hello World!");
Console.Write("줄바꿈이 일어나지 않음");
```

반대로 입력의 경우는 마찬가지로 Console 클래스의 **ReadLine()** 메서드를 사용한다.<br />
ReadLine() 메서드는 사용자로부터 한 줄의 문자열을 입력 받아 해당 문자열을 string 자료형으로 대입한다.

```C#
string input = Console.ReadLine();
```

이렇게 작성할 경우, 프로그램을 실행한 후 사용자가 입력한 문자열을

```C#
Console.WriteLine(input);
```

이런 식으로 출력할 수 있다.


#### 자료형 변환

자료형 변환은 크게 세 가지로 나눠서 다룰 것이다.<br />
첫 번째는 **숫자형 자료형간의 변환**이고, 두 번째는 **숫자형 - 문자열 간의 자료형 변환**이다.<br />
마지막으로는 **문자열에서 불 자료형으로의 변환**에 대해서 다룰 것이다.

1. **숫자 자료형간의 자료형 변환**은 그렇게 복잡하지 않다.<br />
크게 두 가지 경우로 나눌 수 있는데, 우선 첫 번째 경우는 **자동으로 자료형이 변하는 경우**이다.
아래의 코드를 보자.

```C#
int intNum = int.MaxValue;
double doubleNum = 100;

Console.WriteLine(intNum + doubleNum); //실행 결과: 2147483747
Console.WriteLine((intNum + doubleNum).GetType()); //실행 결과: System.Double
```

이와 같이, 서로 다른 연산자 간의 연산일 경우, 연산 결과에 따라 자동으로 큰 타입으로 전환된다.<br />
자동 변환이 가능한 범위는 다음과 같다.

|기존 자료형|자동 변환되는 자료형|
|:---:|:---:|
|int|long, float, double|
|long|float, double|
|char|int, long, float, double|
|float|double|

두 번째 경우는 **강제로 자료형을 변환하는 경우**이다.<br />
강제 자료형 변환은 변환시키고자 하는 자료형 앞에 '(자료형)' 을 붙이면 된다.<br />
아래 코드를 보자.

```C#
long longNum = long.MaxValue;
int intNum = (int)longNum;

Console.WriteLine(intNum); //실행 결과: -1
```

long 타입 자료형인 longNum을 int 자료형인 intNum으로 강제 변환시켰다.<br />
이때, longNum은 long 자료형의 최대값을 담고 있었으므로 당연히 int 자료형의 범위로는 표현이 불가능하다.<br />
그렇기 때문에 실행 결과는 제대로 된 값이 출력되지 않는다.

만약 아래와 같이 longNum이 int 자료형으로 표현 가능한 범위 이내의 수를 담고 있었다면 정상적인 변환이 가능하다.

```C#
long longNum = 100;
int intNum = (int)longNum;

Console.WriteLine(intNum); //실행 결과: 100
```


2. 이번에는 **문자열과 문자열 이외의 자료형간의 변환**을 살펴보자.<br />
위의 입력과 출력에서 언급한 ReadLine() 메서드로 숫자를 입력받아서 둘을 더한 값을 출력해야 한다고 생각해보자.

이를테면 아래와 같다.

```C#
string num1 = Console.ReadLine();
string num2 = Console.ReadLine();

Console.WriteLine("sum: " + (num1 + num2));
```
위 연산의 결과가 과연 num1과 num2의 숫자를 더한 값으로 출력될까?

정답은 '그렇지 않다'이다.<br />
num1과 num2는 현재 모두 문자열로 취급된 상태이기 때문에, <br />위의 연산자 파트에서 읽은 대로 문자열을 그대로 이어서 출력할 뿐이다.<br />
그렇기 때문에 우리가 원하는 덧셈을 하기 위해서는 이 문자열 변수들을 다른 자료형으로 바꾸는 작업이 필요하다.<br />
그럴 때 사용하는 것이 바로 **'자료형.Parse()'** 메서드이다.

> '자료형.Parse()' 메서드의 '자료형' 부분에 int, long, float, double 자료형 중 하나를 넣어서
> 문자열 자료형을 해당 자료형으로 변형시킬 수 있다.

이를테면 아래와 같다.

```C#
Console.WriteLine(int.Parse("52"));
```

위의 "52"는 큰따옴표 안에 들어있으므로 숫자이지만 현재 문자열인 상태이다.<br />
이를 int.Parse() 메서드를 통해 숫자 52로 출력시킬 수 있는 것이다.<br />
당연히 `int num = int.Parse("52");` 와 같이 해당 자료형을 지닌 변수에 대입시키는 것도 가능하다.

또한, 원래 정수 또는 실수형인 자료형을 문자열로 변형해서 표기해야 할 일도 분명 있을 것이다.<br />
그럴때는 'ToString()' 메서드를 사용하면 다른 자료형을 문자열로 변형시킬 수 있다.

> 'ToString()' 메서드 앞에 문자열로 변형할 값을 입력하면 해당 값을 문자열로 변형시킬 수 있다.<br />
> 입력하는 숫자가 소숫점일 경우, ToString()의 괄호 안에 표기할 소수점 자리를 나타낼 수 있다.

이를테면 아래와 같다.

```C#
float number = 52.273104;

Console.WriteLine((52).ToString());
Console.WriteLine(number.ToString("0.00")); //소숫점 셋째 자리 이하는 버려지고 52.27만 출력
```

또한, 문자열로의 변환의 경우, ToString() 메서드를 활용하지 않고서도,
위에서 사용한 '+' 연산자를 이용한 변환이 가능하다.<br />
숫자와 문자열을 '+' 연산자로 연결할 경우, 해당 숫자는 문자열로 변환되어 연산하게 된다.

즉, 아래 내용과 같다.

```C#
Console.WriteLine("52" + 273);
// 실행 결과 : 52273
```


3. 마지막으로 살펴볼 **문자열에서 불 자료형으로의 변환**은 매우 간단하다.<br />
불은 값이 True 또는 False중 하나이므로, 오직 True 또는 False 문자열만을 불 자료형으로 변환할 수 있다.<br />
이 때, 문자열의 대소문자 구분은 하지 않는다.

아래 예시를 보면 바로 알 수 있다.

```C#
Console.WriteLine(bool.Parse("True"));
Console.WriteLine(bool.Parse("false"));
```

---